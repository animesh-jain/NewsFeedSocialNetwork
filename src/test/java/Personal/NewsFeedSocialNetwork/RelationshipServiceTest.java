package Personal.NewsFeedSocialNetwork;
// Generated by CodiumAI

import Personal.NewsFeedSocialNetwork.dao.RelationshipDao;
import Personal.NewsFeedSocialNetwork.enums.RelationshipStatus;
import Personal.NewsFeedSocialNetwork.model.Relationship;
import Personal.NewsFeedSocialNetwork.service.RelationshipService;
import java.util.List;
import java.util.Optional;
import org.apache.coyote.BadRequestException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class RelationshipServiceTest {

	@Mock
	RelationshipDao relationshipDao;

	@InjectMocks
	RelationshipService relationshipService;

	@BeforeEach
	public void setUp() {
		MockitoAnnotations.initMocks(this); // Initialize Mockito annotations
	}

	// create a relationship with valid userId and friendUserId, and verify it is saved in the database
	@Test
	public void test_create_relationship_valid_userId_and_friendUserId() {
		// Arrange
		Long userId = 1L;
		Long friendUserId = 2L;
		Relationship expectedRelationship = Relationship.builder()
		                                                .userId(userId)
		                                                .friendUserId(friendUserId)
		                                                .relationshipStatus(
			                                                RelationshipStatus.PENDING)
		                                                .build();
		Mockito
			.when(relationshipDao.save(Mockito.any(Relationship.class))).thenReturn(expectedRelationship);

		// Act
		Relationship result = relationshipService.createRelationship(userId, friendUserId);

		// Assert
		assertEquals(expectedRelationship, result);
		Mockito.verify(relationshipDao, Mockito.times(1)).save(Mockito.any(Relationship.class));
	}

	// update a relationship with valid relationshipId and relationshipStatus, and verify it is updated in the database
	@Test
	public void test_update_relationship_valid_relationshipId_and_relationshipStatus()
		throws BadRequestException {
		// Arrange
		Long relationshipId = 1L;
		RelationshipStatus relationshipStatus = RelationshipStatus.ACCEPTED;
		Relationship existingRelationship = Relationship.builder()
		                                                .id(relationshipId)
		                                                .userId(1L)
		                                                .friendUserId(2L)
		                                                .relationshipStatus(RelationshipStatus.PENDING)
		                                                .build();
		Relationship expectedRelationship = Relationship.builder()
		                                                .id(relationshipId)
		                                                .userId(1L)
		                                                .friendUserId(2L)
		                                                .relationshipStatus(relationshipStatus)
		                                                .build();
		Mockito.when(relationshipDao.findById(relationshipId)).thenReturn(
			Optional.of(existingRelationship));
		Mockito.when(relationshipDao.save(Mockito.any(Relationship.class))).thenReturn(expectedRelationship);

		// Act
		Relationship result = relationshipService.updateRelationship(relationshipId, relationshipStatus);

		// Assert
		assertEquals(expectedRelationship, result);
		Mockito.verify(relationshipDao, Mockito.times(1)).findById(relationshipId);
		Mockito.verify(relationshipDao, Mockito.times(1)).save(Mockito.any(Relationship.class));
	}

	// create a relationship with userId and friendUserId already in the database, and verify it is not saved
	@Test
	public void test_create_relationship_existing_userId_and_friendUserId() {
		// Arrange
		Long userId = 1L;
		Long friendUserId = 2L;
		Relationship existingRelationship = Relationship.builder()
		                                                .userId(userId)
		                                                .friendUserId(friendUserId)
		                                                .relationshipStatus(RelationshipStatus.PENDING)
		                                                .build();
		Mockito.when(relationshipDao.findAllFriendUserIdByUserIdAndRelationshipStatus(userId, RelationshipStatus.ACCEPTED))
		       .thenReturn(List.of(friendUserId));

		// Act
		Relationship result = relationshipService.createRelationship(userId, friendUserId);

		// Assert
		assertNull(result);
	}
}