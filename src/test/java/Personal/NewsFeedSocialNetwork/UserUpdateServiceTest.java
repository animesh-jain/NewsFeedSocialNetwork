package Personal.NewsFeedSocialNetwork;
// Generated by CodiumAI

import Personal.NewsFeedSocialNetwork.dao.RelationshipDao;
import Personal.NewsFeedSocialNetwork.dao.UserUpdateDao;
import Personal.NewsFeedSocialNetwork.enums.RelationshipStatus;
import Personal.NewsFeedSocialNetwork.model.UserUpdate;
import Personal.NewsFeedSocialNetwork.service.UserUpdateService;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class UserUpdateServiceTest {

	@Mock
	RelationshipDao relationshipDao;

	@Mock
	UserUpdateDao userUpdateDao;

	@InjectMocks
	UserUpdateService userUpdateService;

	@BeforeEach
	public void setUp() {
		MockitoAnnotations.initMocks(this); // Initialize Mockito annotations
	}

	// Creating a new UserUpdate with valid parameters should save it to the database and return the created object.
	@Test
	public void test_create_user_update_with_valid_parameters() {
		// Arrange
		Long userId = 1L;
		Long eventId = 1L;
		boolean like = true;
		String comment = "Test comment";
		boolean share = false;
		String caption = "Test caption";

		UserUpdate expectedUserUpdate = UserUpdate.builder()
		                                          .id(1L)
		                                          .userId(userId)
		                                          .eventId(eventId)
		                                          .like(like)
		                                          .comment(comment)
		                                          .share(share)
		                                          .caption(caption)
		                                          .build();

		Mockito
			.when(userUpdateDao.save(Mockito.any(UserUpdate.class))).thenReturn(expectedUserUpdate);

		// Act
		UserUpdate result = userUpdateService.createUserUpdate(userId, eventId, like, comment, share, caption);

		// Assert
		assertEquals(expectedUserUpdate, result);
	}

	// Retrieving friends' updates for a user with valid parameters should return a list of UserUpdate objects in descending order of creation time.
	@Test
	public void test_get_friends_update_with_valid_parameters() {
		// Arrange
		Long userId = 1L;

		List<Long> friendUserIds = List.of(2L, 3L);

		List<UserUpdate> expectedUserUpdates = List.of(UserUpdate.builder()
		                                                         .id(1L)
		                                                         .userId(2L)
		                                                         .eventId(1L)
		                                                         .like(true)
		                                                         .comment("Test comment 1")
		                                                         .share(false)
		                                                         .caption("Test caption 1")
		                                                         .build(),
			UserUpdate.builder()
			          .id(2L)
			          .userId(3L)
			          .eventId(2L)
			          .like(false)
			          .comment("Test comment 2")
			          .share(true)
			          .caption("Test caption 2")
			          .build());

		Mockito.when(relationshipDao.findAllFriendUserIdByUserIdAndRelationshipStatus(userId, RelationshipStatus.ACCEPTED)).thenReturn(friendUserIds);
		Mockito.when(userUpdateDao.findAllByUserIdInOrderByCreatedAtDesc(friendUserIds)).thenReturn(expectedUserUpdates);

		// Act
		List<UserUpdate> result = userUpdateService.getFriendsUpdate(userId);

		// Assert
		assertEquals(expectedUserUpdates, result);
	}

	// Retrieving a user's updates with valid parameters should return a list of UserUpdate objects in descending order of creation time.
	@Test
	public void test_get_user_update_with_valid_parameters() {
		// Arrange
		Long userId = 1L;

		List<UserUpdate> expectedUserUpdates = List.of(UserUpdate.builder()
		                                                         .id(1L)
		                                                         .userId(userId)
		                                                         .eventId(1L)
		                                                         .like(true)
		                                                         .comment("Test comment 1")
		                                                         .share(false)
		                                                         .caption("Test caption 1")
		                                                         .build(),
			UserUpdate.builder()
			          .id(2L)
			          .userId(userId)
			          .eventId(2L)
			          .like(false)
			          .comment("Test comment 2")
			          .share(true)
			          .caption("Test caption 2")
			          .build());

		Mockito.when(userUpdateDao.findAllByUserIdOrderByCreatedAtDesc(userId)).thenReturn(expectedUserUpdates);

		// Act
		List<UserUpdate> result = userUpdateService.getUserUpdate(userId);

		// Assert
		assertEquals(expectedUserUpdates, result);
	}

	// Creating a new UserUpdate with a non-existent userId should throw an exception.
	@Test
	public void test_create_user_update_with_non_existent_userId() {
		// Arrange
		Long userId = 1L;
		Long eventId = 1L;
		boolean like = true;
		String comment = "Test comment";
		boolean share = false;
		String caption = "Test caption";

		Mockito.when(userUpdateDao.save(Mockito.any(UserUpdate.class))).thenThrow(new IllegalArgumentException("User not found"));

		// Act and Assert
		assertThrows(IllegalArgumentException.class, () -> userUpdateService.createUserUpdate(userId, eventId, like, comment, share, caption));
	}

	// Retrieving friends' updates for a user with a non-existent userId should throw an exception.
	@Test
	public void test_get_friends_update_with_non_existent_userId() {
		// Arrange
		Long userId = 1L;

		Mockito.when(relationshipDao.findAllFriendUserIdByUserIdAndRelationshipStatus(userId, RelationshipStatus.ACCEPTED)).thenThrow(new IllegalArgumentException("User not found"));

		// Act and Assert
		assertThrows(IllegalArgumentException.class, () -> userUpdateService.getFriendsUpdate(userId));
	}

	// Retrieving a user's updates with a non-existent userId should throw an exception.
	@Test
	public void test_get_user_update_with_non_existent_userId() {
		// Arrange
		Long userId = 1L;

		Mockito.when(userUpdateDao.findAllByUserIdOrderByCreatedAtDesc(userId)).thenThrow(new IllegalArgumentException("User not found"));

		// Act and Assert
		assertThrows(IllegalArgumentException.class, () -> userUpdateService.getUserUpdate(userId));
	}

}